
(*
val csynt = RewriteMain.parse_c "example.c";

val _ = printTreeDirect 30 csynt;

val _ = quietdec := true
val grammar_synt = RewriteMain.parse_grammar grammar;
val _ = quietdec := false


val _ = printTreeDirect 30 grammar_synt;

val _ = debug_reset();

fun debug_subst_match_on () =
   let val _ = debug_on "tree_subst" (On 10)
       val _ = debug_on "tree_match" (On 10)
       val _ = debug_on "tree_rewrite" (On 10)
       val _ = debug_on "tree_tree_list_subst_leaves" (On 4)
       val _ = debug_on "rewrite" (On 4)
       val _ = debug_on "tree_subst_branch" (On 4)
   in () end;

val _ = debug_on "tree_unify_subst" (On 10)
val _ = debug_off "tree_unify_subst"
val _ = debug_on "tree_unify_branch" (On 10)
val _ = debug_on "tree_match" (On 10)

val tddeclt = RewriteMain.parse_c_string
       "typedef int s; typedef s *t; typedef int *u;";
val _ = Rewrite.printTreeDirect 30 tddeclt;

val enumdecl = RewriteMain.parse_c_string
  "typedef enum {SIGEV_SIGNAL = 1, SIGEV_NONE, SIGEV_THREAD = 0, SIGEV_THREAD_ID = 4} fred;";

val _ = Rewrite.printTreeDirect 30 enumdecl;

val rewrite_synt = Rewrite.parse_rewrites "../dynlibs/ffi/typedef.rwt";
val _ = print (Rewrite.printRewrites rewrite_synt);

val rwres =  (Rewrite.compileRewrites rewrite_synt);
val rewrite = Rewrite.tree_rewrite "%aquote" "%quote" rwres;
val tddeclt' = rewrite tddeclt;

val _ = debug_off "tree_unify_branch"

val _ = print "\nrewrite gives:\n";

val decllistmatch = 
      Rewrite.compileRewrites
        (Rewrite.parse_rewrites_string
            "⟦declaration-list \
           \    ⌜x:declaration⌝⟧ = \
           \ (⌜x⌝) \
           \ ⟦declaration-list \
           \    ⌜x:declaration-list⌝ \
           \    ⌜y:declaration⌝⟧ = \
           \ (⌜y⌝)")

val _ = debug_on "tree_match" (On 10)
val _ = debug_on "tree_unify_match" (On 10) 
val tdl = tree_match "%quote" decllistmatch tddeclt'
val _ = debug_off "tree_unify_match"
val _ = debug_off "tree_match" 

val _ = print "\ntree_match gives:\n";

val _ = List.app (Rewrite.printTreeDirect 30) tdl

val rewrites = "test.rwt";
val _ = quietdec := true;
val rewrite_synt = Rewrite.parse_rewrites rewrites;
val _ = quietdec := false;

val _ = print (Rewrite.printRewrites rewrite_synt);

val rwres =  (Rewrite.compileRewrites rewrite_synt);
val rewrite' = tree_rewrite "%aquote" "%quote" rwres;

val res' = rewrite' grammar_synt;
val _ = print "\nrewrite' gives:\n";
val _ = Rewrite.printTreeDirect 30 (res');

fun afterFirst t =
   let fun iter [] = []
         | iter (l as (x::xs)) = if x = t then l else iter xs
   in iter
   end;

val ctoks = RewriteMain.tokenise_c "example.h";
val cfrag' = afterFirst (CParser.IDENTIFIER "__val") ctoks;
*)

(*       and resolve_struct_contents tags t =
          case t
             of NonTerm("declaration-specifiers",[t]) =>
                NonTerm("declaration-specifiers",[resolve_struct_contents tags t])
              | NonTerm("type-specifier",[t]) =>
                NonTerm("type-specifier",[resolve_struct_contents tags t])
              | NonTerm("struct-or-union-specifier",
                                         [su,
                                          id as (NonTerm("identifier",[Term(name)])),
                                          NonTerm("struct-contents",[sc])])
                => let val sc' = foldStructDecl
                                     (resolve_decl (name::tags))
                                     (split_structdecl_list sc)
                   in NonTerm("struct-or-union-specifier", [su,id,NonTerm("struct-contents",[sc'])])
                   end
              | NonTerm("struct-or-union-specifier",[su,NonTerm("struct-contents",[sc])])
                => let val sc' = foldStructDecl
                                     (resolve_decl tags)
                                     (split_structdecl_list sc)
                   in NonTerm("struct-or-union-specifier",[su,NonTerm("struct-contents",[sc'])])
                   end
              | _ => (Rewrite.printTree t; raise Fail "resolve_struct_contents: no case") *)
